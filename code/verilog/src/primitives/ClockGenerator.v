/**
 * Clock signal generator:
 * - generates a clock signal on the output line
 * - waits for a start signal, after which generates CYCLE_COUNT clock cycles, then returns to passive state (logic 0)
 * - when ACTIVE_LOW parameter is set, passive state is logic 1 instead
 * - the clock frequency is generated by dividing the system clock
 * - !! the DIV_FACTOR parameter must be even !!
**/

module ClockGenerator #(

	// parameters
	parameter DIV_FACTOR = 12,
	parameter CYCLE_COUNT = 8,
	parameter ACTIVE_LOW = 0
) (

	// inputs
	input wire sys_clk,
	input wire rst,
	input wire start,
	
	// outputs
	output reg out_clk = (ACTIVE_LOW == 0) ? 1'b0 : 1'b1,
	output reg busy = 1'b0
);

	// local constants
	localparam DIV_CTR_MAX = DIV_FACTOR/2 - 1;	// we need to toggle the output 2 times per divided clock cycle
	localparam DIV_CTR_SIZE = $clog2(DIV_CTR_MAX+1);	// storing A requires exactly ceil(lg(A+1)) bits
	localparam CYCLE_CTR_MAX = 2*CYCLE_COUNT - 1;	// every clock cycle toggles output 2 times
	localparam CYCLE_CTR_SIZE = $clog2(CYCLE_CTR_MAX+1);
	
	// states
	localparam STATE_IDLE = 2'd0;
	localparam STATE_CLOCK = 2'd1;
	localparam STATE_DONE = 2'd2;
	localparam STATE_RESET = 2'd3;

	// internal registers
	reg [1:0] state = STATE_RESET;
	reg [DIV_CTR_SIZE-1:0] div_ctr = 0;
	reg [CYCLE_CTR_SIZE-1:0] cycle_ctr = 0;

	always @ (posedge sys_clk)
	begin
		// on reset signal busy and go to reset state
		if (rst == 1'b1) begin
			busy <= 1'b1;
			state <= STATE_RESET;
		end
		
		else begin
			// state transition logic
			case (state)
				
				// in idle state wait for start signal
				STATE_IDLE: begin
					if (start == 1'b1) begin
						busy <= 1'b1;
						state <= STATE_CLOCK;
					end
				end
				
				// main clock generation state
				STATE_CLOCK: begin
					// if all cycles were generated output passive clock level and go to next state
					if (cycle_ctr == CYCLE_CTR_MAX) begin
						out_clk <= (ACTIVE_LOW == 0) ? 1'b0 : 1'b1;
						state <= STATE_DONE;
					end
					
					// else if division counter reached max, reset counter, toggle output and increment cycle counter
					else if (div_ctr == DIV_CTR_MAX) begin
						div_ctr <= 0;
						out_clk <= ~out_clk;
						cycle_ctr <= cycle_ctr + 1;
					end
					
					// else increment division counter
					else begin
						div_ctr <= div_ctr + 1;
					end
				end
				
				// prepare internal state for next clock generation
				STATE_DONE: begin
					div_ctr <= 0;
					cycle_ctr <= 0;
					busy <= 1'b0;
					state <= STATE_IDLE;
				end
				
				// reset internal state
				STATE_RESET: begin
					div_ctr <= 0;
					cycle_ctr <= 0;
					out_clk <= (ACTIVE_LOW == 0) ? 1'b0 : 1'b1;
					busy <= 1'b0;
					state <= STATE_IDLE;
				end
				
			endcase
			
		end
	end
	
endmodule

			